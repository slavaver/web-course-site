---
title: "Сравнение языковых моделей"
description: "Тестируем GPT-4 и DeepSeek на задачах анализа кода"
date: "2025-05-11"
---

_Автор: Трубицин Вячеслав Александрович_

# Введение
Современные языковые модели всё чаще применяются не только для генерации текстов, но и для решения сложных инженерных и программных задач. Особенно интересен их потенциал в области анализа и отладки кода, где требуется не просто "понимать" текст, но и демонстрировать **алгоритмическое мышление**, знание структур данных и умение выявлять ошибки в логике.

В этой статье я сравню две языковые модели — **GPT-4** (разработка OpenAI) и **DeepSeek** (открытая модель, ориентированная на программирование) — на примере задачи анализа некорректной реализации алгоритма бинарного поиска.

Модель получает на вход рабочий, но потенциально ошибочный код, и должна:

- понять, что делает алгоритм;
- найти логическую ошибку;
- объяснить её;
- предложить корректное исправление.

Такой подход позволяет сравнивать модели **не по объёму "знаний"**, а по способности **решать реальные прикладные задачи**, где важны точность, рассуждение и контекстуальное понимание.

# Тест-кейс: Анализ некорректной реализации бинарного поиска

## Задание

Ниже представлен код функции бинарного поиска. В нём нет синтаксических ошибок, но при некоторых входных данных она не возвращает правильный результат.

Проанализируйте код и ответьте на следующие вопросы:

- Что делает этот код?
- В чём заключается ошибка?
- Как её исправить?
- Почему ваше исправление работает?


##  Код

```python
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

print(binary_search(sorted([1, 4, 2, 6, 9, 11]), 11))
```

# Критерии оценки ответа модели

| Критерий                                   |
|--------------------------------------------|
| 1. Правильное понимание алгоритма          |
| 2. Указание на ошибку                      |
| 3. Предложенное исправление                |
| 4. Корректность объяснения                 |
| 5. Дополнительные наблюдения (опционально) |

# На данный тест-кейс модель GPT-4 дала следующий ответ:
```
### Что делает этот код?

Этот код реализует алгоритм бинарного поиска для нахождения индекса элемента (`target`) в отсортированном массиве (`arr`). Он использует стандартную технику разделения массива пополам и сужения области поиска на основе сравнения среднего элемента с целевым значением.

### В чём заключается ошибка?

Ошибка заключается в условии выхода из цикла. Алгоритм работает неправильно, когда массив состоит из одного элемента или когда целевой элемент находится в конце массива. В строке:


`while left < right:`

условие `left < right` продолжает выполняться, пока не останется только один элемент для проверки. Однако, для корректного завершения поиска необходимо, чтобы условие было `left <= right`, чтобы цикл не выходил, пока не проверится последний элемент.

Кроме того, даже если элемент найден на середине, мы не учитываем, что индекс может быть найден в правой половине, и мы должны корректно обновить границы для поиска.

### Как исправить ошибку?

Необходимо изменить условие в цикле с `left < right` на `left <= right`. Это обеспечит правильную работу алгоритма при поиске в массивах с разными размерами и будет учитывать все возможные элементы для поиска.

Исправленный код:


def binary_search(arr, target):
left = 0
right = len(arr) - 1
while left <= right:# Изменили условие с < на <=
	mid = (left + right) // 2
	if arr[mid] == target:             
		return mid         
	elif arr[mid] < target:
	    left = mid + 1
	else:
	    right = mid - 1
	return -1  
print(binary_search(sorted([1, 4, 2, 6, 9, 11]), 11))

### Почему ваше исправление работает?

- При использовании `left <= right` мы гарантируем, что проверка будет выполняться до тех пор, пока границы поиска не сойдутся, и не проверится последний элемент.
    
- В случае с `left < right` цикл может завершиться, не проверив элемент в правой границе, что может привести к неправильному результату. Теперь же с условием `left <= right` мы точно проверим все элементы, включая последний.
    

Таким образом, исправленное условие гарантирует, что бинарный поиск будет работать правильно для всех входных данных, включая массивы с одним элементом, пустые массивы и массивы с элементами на границах.
```
Можем видеть, что модель GPT-4 полностью справилась со своей задачей, дав верный, обоснованный ответ, а так же, продемонстрировав полное понимание кода и описанного в нём алгоритма, предложила верное решение и пояснила, почему именно так необходимо сделать.

# Deepsek же на данный тест-кейс дал следующий ответ:
## Анализ кода бинарного поиска

```

### 1. Что делает этот код?

Это реализация алгоритма бинарного поиска, который ищет заданный элемент (`target`) в отсортированном массиве. Если элемент найден, возвращается его индекс, если нет - возвращается -1.

### 2. В чём заключается ошибка?

Основная ошибка в условии цикла `while left < right:`. В текущей реализации:

- Если искомый элемент находится в крайней правой позиции (как в примере с поиском 11), алгоритм может не найти его
    
- Цикл завершается, когда `left` и `right` становятся равными, не проверя последний оставшийся элемент
    

В приведённом примере `print(binary_search(sorted([1, 4, 2, 6, 9, 11]), 11))` функция вернёт -1, хотя 11 присутствует в массиве.

### 3. Как её исправить?

Нужно изменить условие цикла на `while left <= right:`. Вот исправленный код:

def binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

### 4. Почему ваше исправление работает?

Исправление работает потому что:

1. Условие `left <= right` гарантирует, что будет проверен последний оставшийся элемент (когда `left == right`)
    
2. Это соответствует полному охвату всех возможных позиций элемента в массиве
    
3. В исходной версии при `left == right` цикл завершался без проверки этого элемента
    
4. В примере с поиском 11 теперь алгоритм проверит последний элемент и вернёт правильный индекс
    

Исправленная версия корректно обрабатывает все случаи:

- Элемент в начале массива
    
- Элемент в конце массива
    
- Элемент в середине
    
- Отсутствующий элемент
```
Нейросеть корректно проанализировала код, выявив ошибку в условии цикла и предложив правильное исправление. Модель точно объяснила, почему изменение условия с `left < right` на `left <= right` решает проблему и корректно обрабатывает все возможные случаи бинарного поиска.

# Итог

Обе предложенные модели справились с задачей, показав понимание алгоритма, умение "читать код" и находить, исправлять и объяснять в нём ошибки.
